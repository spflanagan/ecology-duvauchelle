---
title: "Community analysis"
output:
  pdf_document: default
  html_notebook: default
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H",
                      fig.path = "../figs/",dpi = 300,fig.keep='last',dev='png')
knitr::opts_knit$set(root.dir='../results/',fig_path="../figs/")
```
```{r loadLibs, include=FALSE, echo=FALSE}
library(scales)
library(knitr)
library(vegan)
library(indicspecies)
library(dplyr)
library(tidyr)
library(leaflet)
library(magick)
library(adespatial)
source("../R/iDIP.R")
```

```{r}
files.sources <- list.files(path = "../R/hierDiversity",full.names = TRUE)
tmp<-sapply(files.sources, source)

tmp<-sapply(list.files(path="../../spfTools/R/",full.names = TRUE),source)
```


```{r getData}
combdat<-read.csv("cleanedCombinedCommunity.csv",stringsAsFactors = TRUE)
combdat$SeagrassCover<-factor(combdat$SeagrassCover,
                              levels=c("bare","sparse","patchy","dense"))
combdat$Season<-factor(combdat$Season,
                       levels=c("Winter","Spring","Summer","Fall"))
```
```{r}
seasonCols<-c(Spring="coral",Summer="olivedrab3",Fall="gold",Winter="dodgerblue")
seagrassCs<-c(bare="#d9f0a3",sparse="#78c679",patchy="#41ab5d",dense="#005a32")
seasonPchs<-c(Spring=15,Summer=17,Fall=18,Winter=19)
seagrassPs<-c(bare=16, sparse=18, patchy=17, dense=15)
```

```{r getGPS}
gpsdat<-read.csv("../data/gpsdat.csv")
```

```{r}
lat <- c(-43.794,-43.752) #define our map's ylim
lon <- c(172.930,172.933) #define our map's xlim
center <- c(mean(c(gpsdat$lat_start,gpsdat$lat_stop)), 
            mean(c(gpsdat$long_start,gpsdat$long_stop)))  #tell what point to center on
zoom <- 16  #zoom: 1 = furthest out (entire globe), larger numbers = closer in

```



## Community analysis


```{r}
abunds<-as.matrix(combdat[rowSums(combdat[,6:ncol(combdat)])>4,
                          6:ncol(combdat)])
ys<-combdat[rowSums(combdat[,6:ncol(combdat)])>4,
            c("SeagrassCover","Season","TowArea")]
densities<-abunds/combdat[rowSums(combdat[,6:ncol(combdat)])>4,"TowArea"]
# densities
reldensities<-decostand(densities,method="total",MARGIN = 1)
```


add space as a covariate using dbMEM -- this basically maxes it into a case of multiplying the sites/species matrix by the environment matrix and the matrix of locations. 


```{r spatialPackages}
library(ade4)
library(adespatial)
library(adegraphics)
library(spdep)
library(maptools)
```




First, I need to convert the lat/long coordinates to Cartesian X/Y coordinates
```{r convertXY}
# convert to XY coordinates to distances in meters
duvXY<-SoDA::geoXY(rowMeans(gpsdat[,grep("lat",colnames(gpsdat))]),
                   rowMeans(gpsdat[,grep("long",colnames(gpsdat))]), 
                   unit=1)
s.label(duvXY)
```

Then, I need to test for linear trends and detrend the data if the trend surface is significant. This means to regress all variables on the X â€“ Y coordinates and retain the residuals. This can most easily be done using the function `lm()` (Borcard et al. 2011).

```{r}
duvXY<-duvXY[which(rowSums(combdat[,6:ncol(combdat)])>4),]
anova(rda(reldensities,duvXY))
# if significant, detrend
duvDetrend<-resid(lm(as.matrix(reldensities)~ ., data=as.data.frame(duvXY)))
```


### dbMEM

Use adespatial to identify the best threshold level

```{r, eval=FALSE}
thresh<-seq(50,100,10)

# convert neighborhoods to listw objects
listW<-listw.candidates(duvXY,nb='dnear',d2=thresh)

# apply the candidate neighborhood networks to the detrended data
duvThreshRes<-listw.select(x=duvDetrend,
                           candidates = listW)
saveRDS(duvThreshRes,"duvThreshRes.RDS")
```

```{r}
duvThreshRes<-readRDS("duvThreshRes.RDS")
duvThreshRes$best.id
lwBest <- listW[[duvThreshRes$best.id]]
```

Then use `dbmem` with that best threshold (`r duvThresRes$best.id`).

### Borcard 

In the Borcard et al. (2011) book, they find the truncation threshold as the maximum value of the minimum spanning tree of the Euclidean distance matrix -- using `vegan::spantree`. But they also show a distance-based MEM model approach that I think is more appropriate/useful for what I'm trying to do. 


```{r dists, eval=FALSE}
xydist<-dist(duvXY)
spanning<-spantree(xydist)
dmin<-max(spanning$dist)

```
```{r}
xydbmem<-as.data.frame(dbmem(duvXY,silent=FALSE,thresh=70))
# Create null model for forward selection, IF we have a significant result.
MEMrdaNULL <- capscale(duvDetrend ~ 1, data=xydbmem)
# Now run analysis on saturated dbMEM model
(MEMrda <- capscale(duvDetrend ~ ., data=xydbmem))

duvVario<-variogmultiv(duvDetrend, duvXY, nclass=20)

plot(duvVario$d,duvVario$var,ty='b',pch=20,xlab="Distance",ylab="C(distance)")

anova(MEMrda) # suggests spatial relationship 
```

Based on our dmin from the spanning tree, the shortest distance to keep all sites connected is `r dmin`, which is the point at which there are the most connections. However, this is driven by the fact that there are a few samples from way off on one side of the bay; therefore, I'll use smaller distance values.

### Using PCNM approach:
Perform forward selection of the dbmem models. 

```{r}
# create pcoa of coordinates
xypcoa<-cmdscale(xydist,eig=TRUE,k=nrow(duvXY)-1)

# get positive eigenvalues
nbev<-length(which(xypcoa$eig> 0.0000001))

# create data.frame with PCNM variables
duvPCNM<-as.data.frame(xypcoa$points[1:nrow(duvXY),1:nbev])
par(mfrow=c(1,3))
somePCNM <-1:3
for(i in 1:length(somePCNM)) {
plot(duvPCNM[,somePCNM[i]],type="l",ylab=c("PCNM",somePCNM[i]))
}
```
```{r}
# global PCNM on detrended data
duvPCNMrda<-rda(duvDetrend,duvPCNM)
anova.cca(duvPCNMrda) # not significant
forwardSpace <- ordiR2step(MEMrdaNULL, MEMrda, trace=FALSE)
forwardSpace$call
```

```{r}
# recode environmental variables into dummy binary variables
seagrass<-model.matrix(~ys$SeagrassCover)
colnames(seagrass)<-levels(ys$SeagrassCover)

season<-model.matrix(~ys$Season)
colnames(season)<-levels(ys$Season)
And combine the selected forward-selected axes with the space axes. 

duvEnv<-cbind(seagrass,season)

# forward select environmental variables
duvEnvRda<-rda(abunds, duvEnv)
envR2a<-RsquareAdj(duvEnvRda)$adj.r.squared
fwd<-forward.sel(abunds,duvEnv,adjR2thresh = envR2a,nperm=9999)
```{r}
spaceAxes <- cbind(duvXY, xydbmem[, attr(forwardSpace$terms, "term.labels")])
```


### Using the adespatial approach:

Finally, use both environmental variables (separately) in the variance partitioning, along with space. 

```{r}
vp<-varpart(duvDetrend,ys$SeagrassCover,ys$Season,spaceAxes)
par(mfrow=c(1,2))
showvarparts(3,col=c("green", "red", "blue"))
plot(vp, digits=2, bg=c("green", "red", "blue"), Xnames = c("seagrass", "season","spatial"))
```



And then partition variance based on environment and space
Because there are more spatial variables than either of the other explanatory variables, I need to only interpret the adjusted $R^2$ values. 

```{r}
pca.hell<-capscale(abunds~Condition(TowArea), scale = FALSE,data = ys)
vp1 <- varpart(pca.hell$Ybar, 
               ys$SeagrassCover,
               ys$Season,
               duvThreshRes$best$MEM.select)
plot(vp1,Xnames=c("seagrass","season","space"))
kable(dplyr::bind_rows(vp$part$fract,vp$part$indfract),
      row.names = TRUE,
      caption="Results of variance partitioning using spatial variables as covariates.")
```



### Capscale with pcnm?

```{r}
xypcnm<-pcnm(xydist,
             threshold = 50 #from listw.select above
             ) 

capscale(reldensities~ys$SeagrassCover*ys$Season + duvThreshRes$best$MEM.select)
```


### mso approach?

```{r}
seasonRDA<-capscale(abunds~SeagrassCover*Season + Condition(TowArea), 
                 ys,
                 dist="bray")

duvMSO<-mso(seasonRDA,duvXY,permutations=999)
msoplot(duvMSO)
```


### dbrda


```{r}
abunds<-as.matrix(combdat[rowSums(combdat[,6:ncol(combdat)])>4,
                          6:ncol(combdat)])
ys<-combdat[rowSums(combdat[,6:ncol(combdat)])>4,
            c("SeagrassCover","Season","TowArea")]
# change to area, but also maybe include nested date

seasonRDA<-capscale(abunds~SeagrassCover*Season + Condition(TowArea), 
                 ys,
                 dist="bray")
```
```{r}
plot(seasonRDA)
anova(seasonRDA,by="terms")
seasonSum<-summary(seasonRDA)
```

These results suggest that season and seagrass cover -- and their interaction -- are important in determining the community in seagrass beds. 





     type='none',
     xlab=paste0(
       "CAP1 (",
       "% of total; ", 
       "% of constrained)"),
     ylab=paste0(
       "CAP2 (",
       "% of total; ",
     )
       cex=1.5,
       col=scales::alpha(
       ),


legend("topright",c("bare","sparse","patchy","dense"),
       bty='n',
```

### Indicator species analysis

```{r}
coverIndics<-multipatt(abunds,ys$SeagrassCover)
summary(coverIndics)
```

```{r}
seasonIndics<-multipatt(abunds,ys$Season)
summary(seasonIndics)
```


#### exploring indicators

```{r makeSpeciesMap}
make_species_map<-function(gpsdat,speciesdat,speciesName,
                           center,zoom,color="yellow",
                           scale=5){
  long<-rowMeans(gpsdat[gpsdat$TowNum %in% speciesdat$TowNum,
                       c("long_start","long_stop")])
  lat<-rowMeans(gpsdat[gpsdat$TowNum %in% speciesdat$TowNum,
                       c("lat_start","lat_stop")])
  radius<-speciesdat[,speciesName]
  
  m <- leaflet() %>%
    addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
     #addProviderTiles("NASAGIBS.ViirsEarthAtNight2012")
    addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = long, lat = lat, weight = 1,
      radius = radius*scale,col=color)
  
  m
  return(m)
}

```

##### season indicators

```{r kahawai}
kahawai<-combdat[combdat$kahawai>0,]
make_species_map(gpsdat,kahawai,"kahawai",center,zoom)
```
```{r limpets}
limpets<-combdat[combdat$limpets>0,] # not abundant enough
make_species_map(gpsdat,limpets,"limpets",center,zoom)

```
```{r smelt}
# also patchy
smelt<-combdat[combdat$smelt>0,] # lots of smelt on one day
make_species_map(gpsdat,smelt,"smelt",center,zoom)

```

```{r bluecod}
blueCod<-combdat[combdat$blue_cod_juv>0,] # almost all from one day
make_species_map(gpsdat,blueCod,"blue_cod_juv",center,zoom)

```

```{r whitebait}
whitebait<-combdat[combdat$whitebait_below50mm>0,] # almost all from one day
make_species_map(gpsdat,whitebait,"whitebait_below50mm",center,zoom)

```

##### seagrass indicators

```{r arrowCrab}
# not bare
arrowCrab<-combdat[combdat$arrowheadCrab>0,]
make_species_map(gpsdat,arrowCrab,"arrowheadCrab",center,zoom)

```

```{r blenny}
blenny<-combdat[combdat$blenny>0,]
make_species_map(gpsdat,blenny,"blenny",center,zoom,scale=2)

```

```{r stigmatopora}
stigmatopora<-combdat[combdat$s.nigra>0,]
make_species_map(gpsdat,stigmatopora,"s.nigra",center,zoom)

```

```{r whelk}
mudWhelk<-combdat[combdat$mud_whelk>0,]
make_species_map(gpsdat,mudWhelk,"mud_whelk",center,zoom)

```

```{r spotty}
#sparse: also kahawai
spotty<-combdat[combdat$spotty>0,] 
make_species_map(gpsdat,spotty,"spotty",center,zoom)

```

```{r bristleworm}
bristleworm<-combdat[combdat$bristleworm>0,] 
make_species_map(gpsdat,bristleworm,"bristleworm",center,zoom)

```



## Diversity analysis


```{r reformatForDiversity}
# only keep tows with > 0 observations
divdat<-combdat[rowSums(combdat[,6:ncol(combdat)])>0,]
divabunds<-as.matrix(divdat[rowSums(divdat[,6:ncol(divdat)])>0,6:ncol(divdat)])
# relative
relabunds<-decostand(divabunds,method="total",MARGIN = 1)
# densities
divdensities<-divabunds/divdat$TowArea
```


### Rarefaction

```{r}
rarecurve(t(divabunds))
```
```{r, eval=FALSE}
set.seed(8675309)
rars<-lapply(1:999,function(i,dat=divdat){
  dat<-divdat[,6:ncol(divdat)]
  ssz<-sum(dat[which.min(divdat$TowArea),])
  # rarefy
  rar<-suppressWarnings(rrarefy(dat,ssz))
  rownames(rar)<-paste(divdat$Date,
                       divdat$Season,
                       divdat$SeagrassCover,
                       sep="_")
  
  return(rar)
})

relrar<-lapply(rars,decostand,method="total",MARGIN=1)
saveRDS(relrar,"rarefiedCommunities.RDS")
```
```{r}
relrar<-readRDS("rarefiedCommunities.RDS")
```


### Hill numbers analysis

Within seagrass pairwise beta diversity
then you'd use those to calculate the upper levels?

Should my abundances be densities? - try it

```{r}
# hierDiversity takes the non-relativized abundances
grps<-as.matrix(cbind(divdat[,c("SeagrassCover","Season")], # least inclusive to most inclusive L->R
            Site="Duvauchelle"))
divActual<-hierDiversity(divabunds, 
              grps, 
              replace = NULL, 
              reps = 99, 
              q = 1,
              quant = c(0.025, 0.975),
              sims = FALSE)
saveRDS(divAcutal,"divActual.RDS")

divDensities<-hierDiversity(divdensities, 
              grps, 
              replace = NULL, 
              reps = 99, 
              q = 1,
              quant = c(0.025, 0.975),
              sims = FALSE)
saveRDS(divDensities,"divDensities.RDS")
```


```{r, eval=FALSE}
rareQ0<-lapply(rars,
               hierDiversity,
               group=grps,
               replace = NULL,
               reps = 1, 
               q = 0,
               quant = c(0.025, 0.975),
               sims = FALSE)
saveRDS(rareQ0,"rarefied_Q0.RDS")

rareQ1<-lapply(rars,
               hierDiversity,
               group=grps,
               replace = NULL,
               reps = 1, 
               q = 1,
               quant = c(0.025, 0.975),
               sims = FALSE)
saveRDS(rareQ1,"rarefied_Q1.RDS")

rareQ2<-lapply(rars,
               hierDiversity,
               group=grps,
               replace = NULL,
               reps = 1, 
               q = 2,
               quant = c(0.025, 0.975),
               sims = FALSE)
saveRDS(rareQ2,"rarefied_Q2.RDS")
```


```{r}
extract_rarefied_estimates<-function(hdOutputRDS){
  rareQ<-readRDS(hdOutputRDS)
  estimatesQ<-dplyr::bind_rows(lapply(rareQ,function(hierare){
  
    dat<-dplyr::bind_rows(lapply(hierare,function(hiers){
      estimates<-bind_rows(lapply(hiers,function(estimates){
        return(estimates[1,])
      }))
      return(estimates)
    }))
    dat$level<-rownames(dat)
    
    longdat<-tidyr::pivot_longer(data=dat,colnames(dat)[1:5],names_to="diversity")
    return(longdat)
  }))
  
  meanQs<-tapply(estimatesQ$value,paste(estimatesQ$level,estimatesQ$diversity),mean)
  meanQs<-data.frame(mu=meanQs,
                     level=gsub("(\\w+) (\\w+)","\\1",rownames(meanQs)),
                     diversity=gsub("(\\w+) (\\w+)","\\2",rownames(meanQs)),
                     row.names = NULL)
  meanQs$SEM<-tapply(estimatesQ$value,paste(estimatesQ$level,estimatesQ$diversity),sem)
  meanQs$CIvalue<-tapply(estimatesQ$value,paste(estimatesQ$level,estimatesQ$diversity),cim,output="value")
  return(meanQs)
}
```

```{r}
rarefied_summaries<-lapply(list.files(pattern="rarefied_Q.*.RDS"),extract_rarefied_estimates)
names(rarefied_summaries)<-list.files(pattern="rarefied_Q.*.RDS")
```



patchDiversity -- for a single level of groups (like seagrass)





```{r qsPlot_function}
# assumes the columns are q0,q1,q2 and lab_col is the name of the row with the x-axis labels
qsPlot<-function(Qs,lab_col,qcols=c("#a1dab4","#41b6c4","#225ea8")){

  plot(Qs$q0,type="l",xlab=lab_col,ylab="Species diversity",
     ylim=c(0,max(Qs$q0)+2),cex=2,lwd=2,axes=FALSE,col=qcols[1])
  axis(1,labels=c("",as.character(Qs[,lab_col])),at=0:nrow(Qs))
  axis(2,las=2,seq(-10,max(Qs$q0)+5,5))
  points(Qs$q0,pch=19,cex=2,lwd=2,col=qcols[1])
  text(1,Qs$q0[1]-1,"q=0",font = 3,col=qcols[1])
  
  points(Qs$q1,pch=16,col=qcols[2],cex=2,lwd=2)
  points(Qs$q1,lty=2,col=qcols[2],type='l',lwd=2)
  text(1,Qs$q1[1]+1,"q=1",col=qcols[2],font = 3)
  
  points(Qs$q2,pch=17,col=qcols[3],cex=2,lwd=2)
  points(Qs$q2,lty=3,col=qcols[3],type='l',lwd=2)
  text(1,Qs$q2[1]-1,"q=2",col=qcols[3],font = 3)
}
```




```{r DuvQs_Cover,fig.width=8,fig.height=6,fig.keep='high',dpi=300, eval=FALSE}

par(mfrow=c(1,4),oma=c(2.5,2.5,2.5,1.5),mar=c(3,3,3,2))
qsPlot(Qs[grep("bare",rownames(Qs)),],"date")
legend("topleft","Bare",bty='n')

qsPlot(Qs[grep("sparse",rownames(Qs)),],"date")
legend("topleft","Sparse",bty='n')

qsPlot(Qs[grep("patchy",rownames(Qs)),],"date")
legend("topleft","Patchy",bty='n')

qsPlot(Qs[grep("dense",rownames(Qs)),],"date")
legend("topleft","Dense Seagrass",bty='n')

mtext("Species Diversity",2,outer=TRUE)
```


## Summaries

I can create a graph showing the numbers of species for each type of seagrass habitats.

```{r}
duvSummary<-data.frame(
  Status=paste(combdat$Season,combdat$SeagrassCover,sep="_"),
  Leptonotus=combdat$leptonotus,
  Stigmatopora=combdat$s.nigra,
  Shrimp=combdat$shrimp,
  Flounder=combdat$flounder,
  Crabs=rowSums(combdat[,grep("crab",tolower(colnames(combdat)))]),
  Molluscs=rowSums(combdat[,c("Diloma","austrovenus","Lunella_smaragda","mud_whelk","whelk","paphies_australis")]),
  OtherFish=rowSums(combdat[,c("blenny","kahawai","spotty","wrasse","blue_cod_juv","whitebait_below50mm","smelt")]),
  Other=rowSums(combdat[,c("Seastar","sea_squirt","isopod","bristleworm")])
  )

```

```{r}
duvCounts<-as.data.frame(duvSummary %>%
  group_by(Status) %>%
  summarise_all( sum))
duvCounts$Season<-factor(gsub("(\\w+)_\\w+","\\1",duvCounts$Status),
                         levels=c("Winter","Spring","Summer","Fall"))
duvCounts<-duvCounts[,c("Status","Season","Leptonotus","Stigmatopora","Shrimp","Flounder","Crabs","Molluscs","OtherFish","Other")]
```

```{r}
outputCounts<- as.data.frame(dplyr::bind_rows(
  lapply(colnames(duvCounts[,-c(1:2)]),function(column){
    tapply(duvCounts[,column], duvCounts$Season,sum)
  }))
)
rownames(outputCounts)<-colnames(duvCounts[,-c(1:2)])
write.csv(outputCounts,"TotalCountsSummary.csv",quote=FALSE)
```

```{r}
outputCounts<- as.data.frame(dplyr::bind_rows(
  lapply(colnames(combdat[,-c(1:5)]),function(column){
    tapply(combdat[,column], combdat$Season,sum)
  }))
)
rownames(outputCounts)<-colnames(combdat[,-c(1:5)])
write.csv(outputCounts,"TotalCountsAll.csv",quote=FALSE)
```


```{r}
# this plots each species over seasons
#requires a column called "Season" that is a factor. 
CountsPlot<-function(summaryMatrix, spp, sppCols,x.lim=c(0,7),y.lim=c(0,300)){
  
  # adjust the ylimit if necessary
  if(max(summaryMatrix[,spp])>max(y.lim)){
    y.lim[2]<-max(summaryMatrix[,spp])+50
  }
  # make an empty plot
  plot(as.numeric(summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),"Season"]),
       summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),spp[1]],
       xlim=x.lim,
       ylim=y.lim,
       xlab="",
       ylab="",
       cex.lab=2,
       axes=F,
       type='n',
       xpd=TRUE)
  axis(1,at=as.numeric(summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),"Season"]),
       labels=levels(summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),"Season"]),
       lty = 0,las=2,cex.axis=2)
  axis(2,las=1,cex.axis=2)
  
  
  for(i in 1:length(spp)){
    # add points for each species
    points(as.numeric(summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),"Season"]),
       summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),spp[i]],
       col=sppCols[i],
       lwd=2,
       type = "l")
    points(as.numeric(summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),"Season"]),
       summaryMatrix[order(as.numeric(summaryMatrix[,"Season"])),spp[i]],
       pch=21,
       bg=scales::alpha(sppCols[i],0.75),
       col="dark grey",
       cex=3)
  }
}
```


```{r seagrassPlots}
spp<-colnames(duvCounts)[3:ncol(duvCounts)]
sppCols<-c('#8dd3c7','#ffffb3','#b3de69','#80b1d3','#fb8072','#fdb462','#bebada','#fccde5')
names(sppCols)<-duvCounts[,3:ncol(duvCounts)]

```


```{r seagrassPlots}
par(mfrow=c(1,4),mar=c(5,3,2,0),xpd=TRUE,oma=c(0,0,0,0))
CountsPlot(duvCounts[grep("bare",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,3500))
CountsPlot(duvCounts[grep("sparse",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,3500))
CountsPlot(duvCounts[grep("patchy",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,3500))
CountsPlot(duvCounts[grep("dense",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,3500))
```

```{r}
# plot the relative abundances

duvRelSum<-data.frame(
  Status=paste(divdat$Season,divdat$SeagrassCover,sep="_"),
  Leptonotus=relabunds[,"leptonotus"],
  Stigmatopora=relabunds[,"s.nigra"],
  Shrimp=relabunds[,"shrimp"],
  Flounder=relabunds[,"flounder"],
  Crabs=rowSums(relabunds[,grep("crab",tolower(colnames(relabunds)))]),
  Molluscs=rowSums(relabunds[,c("Diloma","austrovenus","Lunella_smaragda","mud_whelk","whelk","paphies_australis")]),
  OtherFish=rowSums(relabunds[,c("blenny","kahawai","spotty","wrasse","blue_cod_juv","whitebait_below50mm","smelt")]),
  Other=rowSums(relabunds[,c("Seastar","sea_squirt","isopod","bristleworm")])
  )

```

```{r}
duvCounts<-as.data.frame(duvRelSum %>%
  group_by(Status) %>%
  summarise_all( sum))
duvCounts$Season<-factor(gsub("(\\w+)_\\w+","\\1",duvCounts$Status),
                         levels=c("Winter","Spring","Summer","Fall"))
duvCounts<-duvCounts[,c("Status","Season","Leptonotus","Stigmatopora","Shrimp","Flounder","Crabs","Molluscs","OtherFish","Other")]
```




```{r getImages}
bare <- image_read('../figs/seagrass_cover_images/Bare.PNG')
bare_png <- image_convert(bare, "png")

sparse <- image_read('../figs/seagrass_cover_images/Sparse.PNG')
sparse_png <- image_convert(sparse, "png")

patchy <- image_read('../figs/seagrass_cover_images/Patchy.PNG')
patchy_png <- image_convert(patchy, "png")

dense <- image_read('../figs/seagrass_cover_images/Dense.PNG')
dense_png <- image_convert(dense, "png")

seagrassPhotos<-image_append(image_scale(c(bare_png,sparse_png,patchy_png,dense_png)))
```




```{r}
png("../figs/relativeAbundanceSummaries.png",width = 1512, height = 400, res = 96)
par(mfrow=c(1,4), oma=c(4,0,2,0), mar=c(4,5.5,1,0),xpd=TRUE)
CountsPlot(duvCounts[grep("bare",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,30))
#rasterImage(bare_png,xleft = 0,xright = 5,ytop = -26,ybottom=-30,xpd=TRUE)
mtext("Relative abundance",side=2,outer=FALSE,line=3,cex=1.5)

CountsPlot(duvCounts[grep("sparse",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,30))
#rasterImage(sparse_png,xleft = 0,xright = 5,ytop = -26,ybottom=-30,xpd=TRUE)

CountsPlot(duvCounts[grep("patchy",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,30))
#rasterImage(patchy_png,xleft = 0,xright = 5,ytop = -26,ybottom=-30,xpd=TRUE)

CountsPlot(duvCounts[grep("dense",duvCounts$Status),],spp=spp,sppCols = sppCols,y.lim = c(0,30))
#rasterImage(dense_png,xleft = 0,xright = 5,ytop = -26,ybottom=-30,xpd=TRUE)


outer_legend("top",spp,col=sppCols,pch=21,pt.bg=sppCols,lty=1,bty='n',ncol=8,cex=2,lwd=2,pt.cex=2)
dev.off()
```


```{r}
relfig<-image_convert(image_read('../figs/relativeAbundanceSummaries.png'),"png")
combinedSummary<-image_append(c(relfig,seagrassPhotos), stack = TRUE)
image_write(combinedSummary,
            path = "../figs/relativeAbundanceSeagrass.png",
            format = "png")
```


