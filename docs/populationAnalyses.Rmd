---
title: "Duvauchelle Population Dynamics"
output:
  pdf_document: default
  html_notebook: default
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H",
                      fig.path = "../figs/",dpi = 300,fig.keep='last',dev='png')
knitr::opts_knit$set(root.dir='../results/',fig_path="../figs/")
```

```{r loadLibs, include=FALSE, echo=FALSE}
library(scales)
library(knitr)
library(dplyr)
library(magick)
library(tidyr)
library(lme4)
library(leaflet)
library(mapview)
```

```{r spfTools}
tmp<-sapply(list.files(path="../../spfTools/R/",full.names = TRUE),source)
multi_tapply<-function(dat,focalCol,factors,FUN,...){
  
  fac<-NULL
  for(i in 1:length(factors)){
    fac<-paste(fac,dat[,factors[i]])
  }
  val<-tapply(dat[,focalCol],
                     fac,
                     match.fun(FUN),...)
  output<-data.frame(matrix(nrow=length(val),ncol=length(factors)+1))
  output[,1]<-val
  for(i in 1:length(factors)){
    output[,i+1]<-unlist(lapply(strsplit(names(val)," "), `[[`, i+1) )
      
      
  }
  colnames(output)<-c("value",factors)
  return(output)

}
```


```{r}
cleandat<-read.csv("../data/cleanedCommunity.csv")
seasonCols<-c(Spring="coral",Summer="olivedrab3",Fall="gold",Winter="dodgerblue")
seagrassCs<-c(bare="#d9f0a3",sparse="#78c679",patchy="#41ab5d",dense="#005a32")
seagrassPs<-c(bare=16, sparse=18, patchy=17, dense=15)
size_cols<-c("#a6bddb","#74a9cf","#2b8cbe","#045a8d")
```



```{r getGPS}
gpsdat<-read.csv("../data/gpsdat.csv")
```

```{r}
lat <- c(-43.794,-43.752) #define our map's ylim
lon <- c(172.930,172.933) #define our map's xlim
center <- c(mean(c(gpsdat$lat_start,gpsdat$lat_stop)), 
            mean(c(gpsdat$long_start,gpsdat$long_stop)))  #tell what point to center on
zoom <- 16  #zoom: 1 = furthest out (entire globe), larger numbers = closer in

```


# Flounder

```{r getFlounderDat}

flounder<-cbind(cleandat[,c("Day","Season","towArea","seagrass_cover",
                            "lat_start","long_start","lat_stop","long_stop")],
                        cleandat[,grep("flounder",colnames(cleandat))])

flounder_long <- gather(flounder, size, count, 9:12, factor_key=TRUE)
flounder_long$size<-factor(gsub("flounder_","",flounder_long$size),
                           levels = c("below10mm","10to20mm","20to50mm","above50mm"))
flounder_long$density<-flounder_long$count/flounder_long$towArea
flounder_long$Season<-factor(flounder_long$Season,
                             levels=c("Winter","Spring","Summer","Fall"))
flounder_long$seagrass_cover<-factor(flounder_long$seagrass_cover,
                                     levels=c("bare","sparse","patchy","dense"))
```

```{r}
par(mfrow=c(2,2))
plot(as.Date(flounder$Day),flounder$flounder_below10mm)
plot(as.Date(flounder$Day),flounder$flounder_10to20mm)
plot(as.Date(flounder$Day),flounder$flounder_20to50mm)
plot(as.Date(flounder$Day),flounder$flounder_above50mm)

```



```{r}
par(mfrow=c(2,2),mar=c(3,4,3.5,2),oma=c(3,2,1,2))
for(i in 1:length(seasonCols)){
  sdat<-flounder_long[flounder_long$Season %in% names(seasonCols)[i],]
  stripchart(sdat$count~sdat$size,
           vertical=TRUE,
           method="jitter",
           jitter=0.05,
           ylab="Number of fish",
           pch=1,
           frame.plot=FALSE,
           axes=FALSE,
           col=seasonCols[i],
           main= names(seasonCols)[i],
           cex.lab=1.2,
           ylim=c(0,50),
           cex=1.5)
  text(x=0.5:3.5,
       y= par("usr")[3] - 15,
       labels = levels(sdat$size),
       xpd = NA,
       srt = 35,
       cex=1.2)
  axis(2,las=2,cex=1.5)
}


```



```{r}
flounderCnts<-data.frame(count=tapply(flounder_long$count,
                     paste(flounder_long$seagrass_cover,
                           flounder_long$Day,
                           flounder_long$Season,
                           flounder_long$size),
                     sum))
flounderCnts$SeagrassCover<-gsub("(\\w+) (\\d+.*) (\\w+) (.*$)","\\1",rownames(flounderCnts))
flounderCnts$Date<-gsub("(\\w+) (\\d+.*) (\\w+) (.*$)","\\2",rownames(flounderCnts))
flounderCnts$Season<-gsub("(\\w+) (\\d+.*) (\\w+) (.*$)","\\3",rownames(flounderCnts))
flounderCnts$SizeClass<-gsub("(\\w+) (\\d+.*) (\\w+) (.*$)","\\4",rownames(flounderCnts))


flounderMeanCnts<-multi_tapply(flounderCnts,"count",c("SeagrassCover","Season","SizeClass"),mean)
flounderMeanCnts$SizeClass<-factor(flounderMeanCnts$SizeClass,
                                   levels=c(
                                     "below10mm",
                                     "10to20mm",
                                     "20to50mm",
                                     "above50mm"
                                   ))
flounderMeanCnts$Season<-factor(flounderMeanCnts$Season,
                                levels=c(
                                  "Winter",
                                  "Spring",
                                  "Summer",
                                  "Fall"
                                ))

flounderSEMCnts<-multi_tapply(flounderCnts,"count",c("SeagrassCover","Season","SizeClass"),sem)
flounderSEMCnts$SizeClass<-factor(flounderSEMCnts$SizeClass,
                                   levels=c(
                                     "below10mm",
                                     "10to20mm",
                                     "20to50mm",
                                     "above50mm"
                                   ))
flounderSEMCnts$Season<-factor(flounderSEMCnts$Season,
                                levels=c(
                                  "Winter",
                                  "Spring",
                                  "Summer",
                                  "Fall"
                                ))

```

```{r}
seagrassPlot<-function(flounderMeanCnts,flounderSEMCnts,cover){
  plot(as.numeric(flounderMeanCnts$Season[flounderMeanCnts$SeagrassCover %in% cover]),
     flounderMeanCnts$value[flounderMeanCnts$SeagrassCover %in% cover],
     type='n',xlab="",ylab="",axes=FALSE,
     ylim=c(0,100),
     cex.lab=2
     )
  axis(1,
       labels = levels(flounderMeanCnts$Season),
       at=1:4,
       pos=0,
       cex.axis=2, 
       las=2)
  axis(2,las=1,cex.axis=2)
  cnt=0
  for(size in levels(flounderMeanCnts$SizeClass)){
    
    subMean<-flounderMeanCnts[flounderMeanCnts$SeagrassCover %in% cover & 
                             flounderMeanCnts$SizeClass %in% size,]
    subMean<-subMean[order(levels(subMean$Season)),]
    xs<-as.numeric(subMean$Season)
    
    subSEM<-flounderSEMCnts[flounderMeanCnts$SeagrassCover %in% cover & 
                             flounderMeanCnts$SizeClass %in% size,]
    arrows(x0=xs,
           x1=xs,
           y0=subMean$value-subSEM$value,
           y1=subMean$value+subSEM$value,
          col=scales::alpha(size_cols[cnt+1],0.5),
          lwd=2,code=3,length=0,xpd=FALSE)
    
    
    cnt<-cnt+1
  }
  cnt=0
  for(size in levels(flounderMeanCnts$SizeClass)){
    
    subMean<-flounderMeanCnts[flounderMeanCnts$SeagrassCover %in% cover & 
                             flounderMeanCnts$SizeClass %in% size,]
    subMean<-subMean[order(levels(subMean$Season)),]
    xs<-as.numeric(subMean$Season)
    
    points(xs,
           subMean$value,pch=cnt+15,col=size_cols[cnt+1],cex=3)
     points(xs,
           subMean$value,type='l',col=size_cols[cnt+1],cex=3)
    
    cnt<-cnt+1
  }
}

```

```{r makeFlounderPlots,eval=FALSE}
png("../figs/flounderPlots.png",width = 1512, height = 300, res = 96)
par(mfrow=c(1,4), oma=c(5,0,2,1), mar=c(2,5.5,1,1),xpd=TRUE)
seagrassPlot(flounderMeanCnts,flounderSEMCnts,"bare")
mtext("Number of flounder",2,outer=FALSE,cex = 1.5,line=3.75)
seagrassPlot(flounderMeanCnts,flounderSEMCnts,"sparse")
seagrassPlot(flounderMeanCnts,flounderSEMCnts,"patchy")
seagrassPlot(flounderMeanCnts,flounderSEMCnts,"dense")

outer_legend("top",bty='n',pch=15:18,col=size_cols,levels(flounderMeanCnts$SizeClass),ncol=4,cex=2,lwd=2)
dev.off()
```
```{r getImages}
bare <- image_read('../figs/seagrass_cover_images/Bare.PNG')
bare_png <- image_convert(bare, "png")

sparse <- image_read('../figs/seagrass_cover_images/Sparse.PNG')
sparse_png <- image_convert(sparse, "png")

patchy <- image_read('../figs/seagrass_cover_images/Patchy.PNG')
patchy_png <- image_convert(patchy, "png")

dense <- image_read('../figs/seagrass_cover_images/Dense.PNG')
dense_png <- image_convert(dense, "png")


seagrassPhotos<-image_append(image_scale(c(
  bare_png,
  sparse_png,
  patchy_png,
  dense_png
)))
```

```{r}
flounderfig<-image_convert(image_read("../figs/flounderPlots.png"), "png")
flounderSeagrass<-image_append(c(flounderfig,
                                 seagrassPhotos), 
                               stack = TRUE)
image_write(flounderSeagrass,
            path = "../figs/FlounderSeagrass.png",
            format = "png")
```


```{r makeSpeciesMap}

long<-rowMeans(flounder[,c("long_start","long_stop")])
lat<-rowMeans(flounder[,c("lat_start","lat_stop")])

# small  
m <- leaflet() %>%
     addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
    #addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = rowMeans(flounder_long[flounder_long$size=="below10mm",
                                            c("long_start","long_stop")]),
               lat = rowMeans(flounder_long[flounder_long$size=="below10mm",
                                       c("lat_start","lat_stop")]),
               weight = 1,
               radius = 1*flounder_long[flounder_long$size=="below10mm","count"],
               col=jsonlite::toJSON(seasonCols[flounder_long[flounder_long$size=="below10mm","Season"]]))
  
m

# 10 to 20
m <- leaflet() %>%
     addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
    #addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = rowMeans(flounder_long[flounder_long$size=="10to20mm",
                                            c("long_start","long_stop")]),
               lat = rowMeans(flounder_long[flounder_long$size=="10to20mm",
                                       c("lat_start","lat_stop")]),
               weight = 1,
               radius = 1*flounder_long[flounder_long$size=="10to20mm","count"],
               col=jsonlite::toJSON(seasonCols[flounder_long[flounder_long$size=="10to20mm","Season"]]))
  
m

# 20 to 50
m <- leaflet() %>%
     addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
    #addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = rowMeans(flounder_long[flounder_long$size=="20to50mm",
                                            c("long_start","long_stop")]),
               lat = rowMeans(flounder_long[flounder_long$size=="20to50mm",
                                       c("lat_start","lat_stop")]),
               weight = 1,
               radius = 1*flounder_long[flounder_long$size=="20to50mm","count"],
               col=jsonlite::toJSON(seasonCols[flounder_long[flounder_long$size=="20to50mm","Season"]]))
  
m

# large ones
m <- leaflet() %>%
     addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
    #addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = rowMeans(flounder_long[flounder_long$size=="above50mm",
                                            c("long_start","long_stop")]),
               lat = rowMeans(flounder_long[flounder_long$size=="above50mm",
                                       c("lat_start","lat_stop")]),
               weight = 1,
               radius = 1*flounder_long[flounder_long$size=="above50mm","count"],
               col=jsonlite::toJSON(seasonCols[flounder_long[flounder_long$size=="above50mm","Season"]]))
  
m


```

```{r }
cleandat$flounder<-rowSums(cleandat[,grep("flounder",colnames(cleandat))])
make_species_map(gpsdat,cleandat,"flounder",center,zoom,scale = 1)
```


## Flounder GLM


Do flounder of different sizes have different abundances throughout the year AND in different seagrass beds?

Looking at patterns of counts (Fig. \@ref(fig:ExploreFlounderPlots)), we can see that the flounder counts do seem to vary with the variables. 

```{r reorderCols}
seasonCols<-seasonCols[levels(flounder_long$Season)]
seagrassCs<-seagrassCs[levels(flounder_long$seagrass_cover)]
```

```{r ExploreFlounderPlots, fig.cap="Plots of the relationship between raw counts and each of the variables of interest.",fig.height=4,fig.width=8.5}
par(mfrow=c(1,4), las=1)
plot(flounder_long$count~jitter(as.integer(flounder_long$Season)),
     xlab="Season", ylab="Raw counts",col=alpha(seasonCols[flounder_long$Season],0.5),
     pch=19,cex=2,bty='L',cex.lab=1.5,xaxt='n',cex.axis=1.5)
axis(1,labels=levels(flounder_long$Season),at=1:length(levels(flounder_long$Season)), cex.axis=1.5)
plot(flounder_long$count~jitter(as.numeric(flounder_long$seagrass_cover)),
     xlab="Seagrass cover", ylab="", col=alpha(seagrassCs[flounder_long$seagrass_cover],0.5),
     pch=19,cex=2,bty='L',cex.lab=1.5,xaxt='n',cex.axis=1.5)
axis(1,labels=levels(flounder_long$seagrass_cover),at=1:length(levels(flounder_long$seagrass_cover)),cex.axis=1.5)
plot(flounder_long$count~jitter(as.numeric(flounder_long$size)),
     xlab="Size class",ylab="",col=alpha(size_cols[flounder_long$size],0.5),
     pch=19,cex=2,bty='L',cex.lab=1.5,cex.axis=1.5,xaxt='n',cex.axis=1.5)
axis(1,labels=levels(flounder_long$size),at=1:length(levels(flounder_long$size)),cex.axis=1.5)
plot(flounder_long$count~flounder_long$towArea,
     xlab="Tow Area", ylab="",col=alpha('#242424',0.5),
     pch=19,cex=2,bty='L',cex.lab=1.5,cex.axis=1.5)
```

Before going forward, we should also check if covariates are highly correlated (they don't seem to be, and are categorical):

```{r}
plot(flounder_long[,c("Season","seagrass_cover","size","towArea")])
```

Challenges with this dataset:

- We are modelling count data, which is not well modeled by OLS
- Log-transforming the data did not change the distribution sufficiently (\@ref(fig:flounderDistributions))
- The variance is `r var(flounder_long$count)` and the mean is `r mean(flounder_long$count)`
- The data has many zeroes

```{r flounderDistributions}
par(mfrow=c(2,2))
hist(flounder_long$count,xlab="Counts", ylab="Number of observations", main="Distribution of raw counts")
hist(flounder_long$count,xlab="ln(Counts)", ylab="Number of observations", main="Distribution of raw counts")
hist(flounder_long$count,xlab="Density (counts/m^2)", ylab="Number of observations", main="Distribution of raw densities")
hist(flounder_long$density,xlab="ln(Density)", ylab="Number of observations", main="Distribution of log-transformed densities")
```


All of this together points to the need to at a minimum use a negative binomial distribution, and possibly (probably) we will need to use a zero-inflated negative binomial. 


My initial attempts using a negative binomial resulted in some models that don't fit that well, because they have some really large deviations from the assumptions of the homogeneity of variances in the residuals.

```{r}
flounderGLM8<-MASS::glm.nb(flounder_long$count ~ 1+ flounder_long$seagrass_cover/flounder_long$Season  * flounder_long$size *flounder_long$towArea)


par(mfrow=c(1,5))
plot(flounder_long$count,flounderGLM8$residuals)
plot(as.factor(flounder_long$Season),flounderGLM8$residuals)
plot(as.factor(flounder_long$seagrass_cover),flounderGLM8$residuals)
plot(as.factor(flounder_long$size),flounderGLM8$residuals)
plot(flounder_long$towArea,flounderGLM8$residuals)
```

```{r}
flounderGLM8<-MASS::glm.nb(flounder_long$density ~ 1+ flounder_long$Season * flounder_long$seagrass_cover * flounder_long$size + flounder_long$towArea)


par(mfrow=c(1,5))
plot(flounder_long$count,flounderGLM8$residuals)
plot(as.factor(flounder_long$Season),flounderGLM8$residuals)
plot(as.factor(flounder_long$seagrass_cover),flounderGLM8$residuals)
plot(as.factor(flounder_long$size),flounderGLM8$residuals)
plot(flounder_long$towArea,flounderGLM8$residuals)
```

So now I'm going to try a zero-inflated negative binomial:

```{r}
library(pscl)
m0<-zeroinfl(flounder_long$count ~ 1,
             dist="negbin")
m1<-zeroinfl(flounder_long$count ~ 1+ flounder_long$seagrass_cover/flounder_long$Season  + flounder_long$size +flounder_long$towArea,
             dist="negbin")
m2<-zeroinfl(flounder_long$count ~ 1+ flounder_long$seagrass_cover+flounder_long$Season  + flounder_long$size +flounder_long$towArea,
             dist="negbin")

aic<-AIC(m0,m1,m2)
aic<-aic[order(aic[,2]),]
```
```{r}
plot(m1$fitted.values,m1$residuals,xlab="Fitted",ylab="Residuals")
```


```{r}
par(mfrow=c(1,5))
plot(flounder_long$count,m1$residuals)
plot(as.factor(flounder_long$Season),m1$residuals)
plot(as.factor(flounder_long$seagrass_cover),m1$residuals)
plot(as.factor(flounder_long$size),m1$residuals)
plot(flounder_long$towArea,m1$residuals)

```
```{r}
# Dispersion Statistic
E2 <- resid(m1, type = "pearson")
N  <- nrow(flounder_long)
p  <- length(coef(m1)) + 1 # '+1' is due to theta
disp<-sum(E2^2) / (N - p)
```

The dispersion statistic is `r disp`, which seems reasonably small (and reasonably close to mean counts, which is `r mean(flounder_long$count)`).

I'm checking the model fit based on the recommendations from [Stack Overflow](https://stackoverflow.com/questions/30103001/assessing-performance-of-a-zero-inflated-negative-binomial-model).

```{r}
# store observed values, and determine how many are nonzero
obs <- flounder_long$count
obs.nonzero <- obs > 0
table(obs)
nonzeroTab<-table(obs.nonzero)
```

There are `r nonzeroTab[[1]]` observations that are zero, and the remaining `r nonzeroTab[[2]]` are non-zero.


```{r flounderPredsCount, fig.cap="Predicted counts from the zero-inflated negative binomial model."}
# calculate predicted counts, and check their distribution
preds.count <- predict(m1, type="response")
plot(density(preds.count))
```
```{r flounderPredsProb, fig.cap="Predicted probability that each item iz non-zero."}
# also the predicted probability that each item is nonzero
preds <- 1-predict(m1, type = "prob")[,1]
preds.nonzero <- preds > 0.5
plot(density(preds))
nonzeroPreds<-table(preds.nonzero)
```

The model predicts that there would be `r nonzeroPreds[[1]]` zero observations and `r nonzeroPreds[[2]]` non-zero observations.

```{r}
# the confusion matrix is obtained by tabulating the dichotomized observations and predictions
confusion.matrix <- table(preds.nonzero, obs.nonzero)
FNR <- confusion.matrix[2,1] / sum(confusion.matrix[,1])
```

Using the confusion matrix (tabulating the zero and non-zero observations and predictions), we can calculate the false negative rate to be `r FNR`.


```{r, fig.cap="Predicted counts compared to observed counts. The model does well for the smaller counts but performs poorly for large count observations."}
 # let's look at how well the counts are being predicted
library(ggplot2)
output <- as.data.frame(list(preds.count=preds.count, obs=obs))
ggplot(aes(x=obs, y=preds.count), data=output) + geom_point(alpha=0.3) + geom_smooth(col="blue")
```
```{r, fig.cap="Log-transformed observed counts compared to predicted counts, only showing non-zero counts."}
output$log.obs <- log(output$obs)
output$log.preds.count <- log(output$preds.count)
ggplot(aes(x=log.obs, y=log.preds.count), data=output[!is.na(output$log.obs) & !is.na(output$log.preds.count),]) + geom_jitter(alpha=0.3, width=.15, size=2) + geom_smooth(col="blue") + labs(x="Observed count (non-zero, natural logarithm)", y="Predicted count (non-zero, natural logarithm)")

```

We can use a regression of observed counts on predicted counts to evaluate the relationship between non-zero predicted and actual counts.
```{r}
calibrate <- lm(log(preds.count) ~ log(obs), data=output[output$obs!=0 & output$preds.count!=0,])
summary(calibrate)
sigma <- summary(calibrate)$sigma
```

The relationship is significant (p = `r summary(calibrate)$coefficients[2,4]`), with an estimated slope of `r calibrate$coefficients[[2]]`. The residual standared error is `r sigma`.

```{r, eval=FALSE}
covariates <- names(Solea)[!( names(Solea) %in% c("Sample", "Area", "Solea_solea"))]

getBetaAndSe <- function(covar)
    coef(summary(glm(Solea_solea ~ Solea[[covar]], data = Solea, family = "binomial")))[2,1:2]

# a Loop:
beta.table <- data.frame(variable = covariates, estimate = NA, se = NA)
for(i in 1:length(covariates))
    beta.table[i,2:3] <- getBetaAndSe(covariates[i])

# plyr and magrittr piping one-liner 
## (Less code, but also less tansparent)
  require(magrittr)
    beta.table2 <- adply(t(covariates), 2, getBetaAndSe) %>% mutate(X1 = covariates)
```
```{r, eval=FALSE}
par(mar = c(3,10,2,2))
beta.table <- mutate(beta.table, low = estimate - 2 * se, high = estimate + 2*se)
n <- nrow(beta.table)
with(beta.table, {
    plot(estimate, 1:n, pch = 19, xlim = c(min(low), max(high)), 
         yaxt = "n", ylab="")
    segments(low, 1:n, high, 1:length(high))
    axis(2, at = 1:n, label = variable, las = 2, cex =0.8)
    abline(v = 0, lwd = 2, lty = 3, col="darkgrey")
})

```

While controlling for sampling dates, and accounting for size classes, flounder were most abundant in fall and least abundant in summer.  
(what about seagrass cover?)




# Pipefish

Questions:

- Are pipefish associated with particular habitat types?
- perhaps intertidal vs subtidal?
- When are pipefish breeding during the year?
- Do the two species differ in these patterns?


```{r}

keep_cols<-c("Day","Season","seagrass_cover","towArea","TowNum","lat_start","long_start","lat_stop","long_stop",
             grep("s\\.nigra",colnames(cleandat),value=T),grep("leptonotus",colnames(cleandat),value=T))
pipedat<-cleandat[,keep_cols]
```

```{r}
pipeTraits<-read.csv("../data/pipefishTraits.csv",stringsAsFactors = TRUE)
pipefishCnts<-read.csv("../data/pipefishCnts.csv",stringsAsFactors=TRUE)
```
```{r}
pipecols<-c(Leptonotus='#8dd3c7',Stigmatopora='#ffffb3')
```




```{r}

par(mfrow=c(1,2))
plot(pipeTraits$TotalLength_Avg~pipeTraits$Season*as.factor(pipeTraits$Species))

```
```{r}
traitLM<-lm(pipeTraits$TotalLength_Avg~pipeTraits$Season*pipeTraits$Species)
par(mfrow=c(2,2))
plot(traitLM)
```

Is status (juvenile, adult, absent) predicted by season and species? 

```{r}
library(nnet)

ageGLM0<-multinom(size~1, data=pipefishCnts) 
ageGLM1<-multinom(size~1+Season*seagrass_cover*species, data=pipefishCnts) # does not converge
ageGLM2<-multinom(size~1+seagrass_cover/Season*species, data=pipefishCnts)
ageGLM3<-multinom(size~1+seagrass_cover/Season+species, data=pipefishCnts)
ageGLM4<-multinom(size~1+seagrass_cover*Season+species, data=pipefishCnts)

AIC(ageGLM0,ageGLM1,ageGLM2,ageGLM3,ageGLM4)
```

```{r}
z0 <- summary(ageGLM0)$coefficients/summary(ageGLM0)$standard.errors
z3 <- summary(ageGLM3)$coefficients/summary(ageGLM3)$standard.errors
z4 <- summary(ageGLM4)$coefficients/summary(ageGLM4)$standard.errors

p0 <- (1 - pnorm(abs(z0), 0, 1)) * 2
p3 <- (1 - pnorm(abs(z3), 0, 1)) * 2
p4 <- (1 - pnorm(abs(z4), 0, 1)) * 2
```

```{r}
anova(ageGLM0,ageGLM3,ageGLM4)
```

The log-likelihood difference indicates new variance explained by the model. Both of our parameterized models fit better than the null model with no parameters, but the / vs * models are the same (no difference).

Checking the model assumptions:

no outliers, high leverage values, or highly influential points for the scale/continuous variables.

```{r}

par(mfrow=c(1,4))
plot(pipefishCnts$size,ageGLM4$residuals)
plot(pipefishCnts$Season,ageGLM4$residuals)
plot(pipefishCnts$seagrass_cover,ageGLM4$residuals)
plot(pipefishCnts$species,ageGLM4$residuals)
```

The residuals seem to be reasonably centred around zero? 


We can test the goodness of fit by examining the predicted values. We'll use the * model for now, as I'm more confident that it is specified correctly.

```{r}
summary(predict(ageGLM4))
```

All of the predictions, when categorized as a count, are for an absence.

```{r}
combos <- data.frame(seagrass_cover = rep(c("bare","sparse", "patchy", "dense"), each=8), 
                      Season = rep(c("Winter","Spring","Summer","Fall"),4),
                     species = rep(c("stigmatopora","leptonotus"),each=4),
                     stringsAsFactors = TRUE)
combos$seagrass_cover<-factor(combos$seagrass_cover,
                              levels=c("bare","sparse", "patchy", "dense"))
combos$Season<-factor(combos$Season,
                              levels=c("Winter","Spring","Summer","Fall"))

## store the predicted probabilities for each value of ses and write
pp.combos <- cbind(combos, predict(ageGLM4, newdata = combos, type = "probs", se = TRUE))

comboMelt <- reshape2::melt(pp.combos, id.vars = c("seagrass_cover", "Season","species"), value.name = "probability")
```

What if we want to add confidence intervals?
```{r}

library(effects)
fit.eff<-Effect(c("seagrass_cover","Season","species"), ageGLM4)


pipefishProbs<-data.frame(fit.eff$x, 
                          fit.eff$prob, 
                          fit.eff$lower.prob, 
                          fit.eff$upper.prob,
                          stringsAsFactors = TRUE)

pipePivot<-pivot_longer(pipefishProbs,
                        4:12,
                        names_to="estimate",
                        values_to="value")
pipePivot$variable<-gsub("(\\w)?\\.?prob\\.(\\w+)","\\2",pipePivot$estimate)
pipePivot$estimate<-gsub("(\\w)?\\.?prob\\.(\\w+)","\\1",pipePivot$estimate)
pipePivot$estimate[pipePivot$estimate==""]<-"probability"

pipePivot<-pivot_wider(pipePivot, names_from="estimate",values_from = "value")
pipePivot<-data.frame(pipePivot,stringsAsFactors = TRUE)
pipePivot$seagrass_cover<-factor(pipePivot$seagrass_cover,
                              levels=c("bare","sparse", "patchy", "dense"))
pipePivot$Season<-factor(pipePivot$Season,
                              levels=c("Winter","Spring","Summer","Fall"))
pipePivot$variable<-as.factor(pipePivot$variable)
```

```{r}
PlotPipefishProbs<-function(predictedProbs, spp,stt,
                            seagrassCs, seagrassPs){
  
  dat<-predictedProbs[which(predictedProbs$species==spp &
                       predictedProbs$variable==stt),]
  
  ymin<-min(dat$probability,na.rm=TRUE)-0.1
  if(ymin<0) ymin<-0
  ymax<-max(dat$probability,na.rm=TRUE)+0.1
  if(ymax>1) ymax<-1
  plot(probability~as.numeric(Season),
       data=dat[which(dat$seagrass_cover=="bare"),],
       pch=seagrassPs[1],
       cex=2,
       axes=FALSE,
       bty='L',
       xlab="Season",
       col=seagrassCs[1],
       ylim=c(ymin,ymax))
  axis(1,at=1:4,labels=levels(dat$Season),pos=ymin,
       cex.axis=1.5,lty=0)
  axis(2,las=1,cex.axis=1.5)
  
  # add confidence intervals
  lapply(1:length(levels(dat$seagrass_cover)),function(i){
    cvr<-levels(dat$seagrass_cover)[i]
    d<-dat[which(dat$seagrass_cover==cvr),]
    arrows(x0 = as.numeric(d$Season),
           x1= as.numeric(d$Season),
           y0=d$L, y1=d$U,
           col=seagrassCs[i],0.25, 
           angle=90,
           length=0,
           lwd=2,
           xpd=FALSE)
  })
   # add points
  lapply(1:length(levels(dat$seagrass_cover)),function(i){
    cvr<-levels(dat$seagrass_cover)[i]
    points(probability~as.numeric(Season),
       data=dat[which(dat$seagrass_cover==cvr),],
       pch=seagrassPs[i],
       col=seagrassCs[i],
       cex=2)
  })
  # add connecting lines
  lapply(1:length(levels(dat$seagrass_cover)),function(i){
    cvr<-levels(dat$seagrass_cover)[i]
    d<-dat[which(dat$seagrass_cover==cvr),]
    points(probability~as.numeric(Season),
       data=d[order(as.numeric(d$Season)),],
       type='l',
       lty=i,
       col=seagrassCs[i],
       lwd=2)
  })
}
```

```{r,fig.width=639,fig.height=478}

par(mfcol=c(3,2),xpd=TRUE,mar=c(2,2,2,2),oma=c(3,4,3,2))
sp<-lapply(levels(pipePivot$variable),
           PlotPipefishProbs,
           predictedProbs=pipePivot,
           spp="stigmatopora",
           seagrassCs=seagrassCs,
           seagrassPs=seagrassPs)
sl<-lapply(levels(pipePivot$variable),
           PlotPipefishProbs,
           predictedProbs=pipePivot,
           spp="leptonotus",
           seagrassCs=seagrassCs,
           seagrassPs=seagrassPs)
l<-outer_legend("bottom",
             levels(pipePivot$seagrass_cover),
             col=seagrassCs,
             pch=seagrassPs,
             lty=1:4,
             lwd=2,
             bty='n',
             ncol=4,
             cex=1.5)
mtext("Probability",2,outer=TRUE,line=1.75)

mtext("absent",4,outer=TRUE,line=-5,las=1,padj=-14.5,font=2)
mtext("adults",4,outer=TRUE,line=-5,las=1,padj=-4,font=2)
mtext("juveniles",4,outer=TRUE,line=-5,las=1,padj=6.5,font=2)

mtext("Stigmatopora nigra",3,outer=TRUE,font=3,adj=0.1)
mtext("Leptonotus elevatus",3,outer=TRUE,font=3,adj=0.8)
```




## violin plots

```{r}
sppCols<-c('#8dd3c7','#ffffb3','#b3de69','#80b1d3','#fb8072','#fdb462','#bebada','#fccde5')
names(sppCols)<-c("Leptonotus","Stigmatopora","Shrimp","Flounder","Crabs","Molluscs","OtherFish","Other")

with(pipeTraits[pipeTraits$Species=="Stigmatopora nigra",] , violin_plot( 
  TotalLength_Avg[Status=="juvenile"] , 
  TotalLength_Avg[Status=="female"], 
  TotalLength_Avg[Status=="nonpregnant"],
  TotalLength_Avg[Status=="pregnant"],  
  col=sppCols["Stigmatopora"] ,
  names=c("juvenile","female","nonpregnant","pregnant"),
  colMed = "black",
  rectCol = "grey",
  ylim=c(0,200)
))


with(pipeTraits[pipeTraits$Species=="Leptonotus elevatus",] , violin_plot( 
  TotalLength_Avg[Status=="juvenile"] , 
  TotalLength_Avg[Status=="female"], 
  col=sppCols["Leptonotus"] ,
  names=c("juvenile","female") ,
  colMed = "black",
  rectCol="grey",
  ylim=c(0,200)
))

```


## pipefish map

```{r makeSpeciesMap}
make_2spp_map<-function(gpsdat,
                        species1dat,
                        species2dat,
                        species1Name,
                        species2Name,
                        center,
                        zoom,
                        color=c("yellow","blue"),
                        scale=5){
  long1<-rowMeans(gpsdat[gpsdat$TowNum %in% species1dat$TowNum,
                       c("long_start","long_stop")])
  lat1<-rowMeans(gpsdat[gpsdat$TowNum %in% species1dat$TowNum,
                       c("lat_start","lat_stop")])
  radius1<-species1dat[,species1Name]
  
  long2<-rowMeans(gpsdat[gpsdat$TowNum %in% species2dat$TowNum,
                       c("long_start","long_stop")])
  lat2<-rowMeans(gpsdat[gpsdat$TowNum %in% species2dat$TowNum,
                       c("lat_start","lat_stop")])
  radius2<-species2dat[,species2Name]
  
  m <- leaflet() %>%
    addTiles() %>%  # Add default OpenStreetMap map tiles
    setView(lng=center[2], lat=center[1],zoom=zoom) %>% 
     #addProviderTiles("NASAGIBS.ViirsEarthAtNight2012")
    addProviderTiles("Esri.WorldImagery") %>%
    addCircles(lng = long1, lat = lat1, weight = 1,
      radius = radius1*scale,col=color[1])%>%
    addCircles(lng = long2, lat = lat2, weight = 1,
      radius = radius2*scale,col=color[2]) 
  
  m
  return(m)
}

```

```{r pipefishMap}
stigmatopora<-cleandat[cleandat$s.nigra_above50mm>0 | cleandat$s.nigra_below50mm > 0,]
stigmatopora$species<-"Stigmatopora"
leptonotus<-cleandat[cleandat$leptonotus_above50mm>0 |cleandat$leptonotus_below50mm > 0,]
leptonotus$species<-"Leptonotus"
pipedat<-bind_rows(stigmatopora,leptonotus)

m<-make_2spp_map(gpsdat,
                 stigmatopora,
                 leptonotus,
                 "s.nigra_above50mm",
                 "leptonotus_above50mm",
                 center,
                 15,
                 c("#ffffb3","#8dd3c7"),
              scale=10)
m %>%
    addLegend("bottomright", 
            colors = c("#ffffb3","#8dd3c7"), 
            labels = c("Stigmatopora nigra","Leptonotus elevatus"),
    title = "Species",
    opacity = 1
  )
mapshot(m, file = "../figs/pipefishMap.png")

```





```{r, eval=FALSE}
png("../figs/DuvauchelleTrends.png",height=6,width=6,units="in",res=300)
par(mfrow=c(2,1),oma=c(1,1,1,1),mar=c(4,4,1,1))
# counts
plot(cnts$juvenile~cnts$date,las=2,
     xlab="",ylab="Number of individuals",
     pch=0,lty=2,lwd=2,cex=2,xaxt='n',bty='n',
     col="dark grey",ylim=c(0,25))
lines(cnts$juvenile~cnts$date,lwd=2,lty=2,col="dark grey")
axis(1,pos=0,labels=cnts$date,at=cnts$date,las=2)

points(cnts$female~cnts$date,
       lwd=2,cex=2,col="#af8dc3")
lines(cnts$female~cnts$date,lwd=2,lty=3,col="#af8dc3")

points(cnts$male~cnts$date,pch=2,
       lwd=2,cex=2,col="#7fbf7b")
lines(cnts$male~cnts$date,lwd=2,lty=1,col="#7fbf7b")
legend("topleft",c("males","females","juveniles"),
       col=c("#7fbf7b","#af8dc3","dark grey"),
       pch=c(2,1,0),pt.cex =2,lwd=2,lty=c(1,3,2),bty='n')

# sizes
par(mar=c(6,4,1,1))
plot(duv_sizes$SVL_Avg~duv_sizes$date,
        xlab="",las=2,ylab="SVL (mm)",
     col=c("dark grey","#af8dc3","#7fbf7b")[duv_sizes$Sex],
     pch=c(0,1,2)[duv_sizes$Sex],
     xlim=c(min(unique(cnts$date)),max(unique(cnts$date))),
     cex=2,lwd=2,xaxt='n',bty='n',ylim=c(20,80))
abline(h=25,lty=4,col="light grey",lwd=2)
axis(1,at=unique(cnts$date),labels=ymd(unique(cnts$date)),las=2)
dev.off()
```







# Shrimp

```{r}
shrimp<-cbind(cleandat[,c("Day","Season","towArea","seagrass_cover",
                            "lat_start","long_start","lat_stop","long_stop")],
                        cleandat[,grep("shrimp",colnames(cleandat))])

shrimp_long <- gather(shrimp, size, count, 9:10, factor_key=TRUE)
shrimp_long$size<-factor(gsub("shrimp_","",shrimp_long$size),
                         levels=c("below20mm","above20mm"))
shrimp_long$density<-shrimp_long$count/shrimp_long$towArea


```

```{r}
par(mfrow=c(2,2),mar=c(3,4,3.5,2),oma=c(3,2,1,2))
for(i in 1:length(seasonCols)){
  sdat<-shrimp_long[shrimp_long$Season %in% names(seasonCols)[i],]
  stripchart(sdat$count~sdat$size,
           vertical=TRUE,
           method="jitter",
           jitter=0.05,
           ylab="Number of shrimp",
           pch=1,
           frame.plot=FALSE,
           axes=FALSE,
           col=seasonCols[i],
           main= names(seasonCols)[i],
           cex.lab=1.2,
           ylim=c(0,300),
           cex=1.5)

  axis(1,at=c(1,2),labels=levels(sdat$size),cex=1.2)
  axis(2,las=2,cex=1.5)
}


```
```{r shrimpGLMs}
shrimpGLM1<-glm(shrimp_long$count ~ 1, family="poisson")
# additive effects
shrimpGLM2<-glm(shrimp_long$count ~ 1+ shrimp_long$Season,family="poisson")
shrimpGLM3<-glm(shrimp_long$count ~ 1+ shrimp_long$Season + shrimp_long$seagrass_cover,family="poisson")
shrimpGLM4<-glm(shrimp_long$count ~ 1+ shrimp_long$Season + shrimp_long$seagrass_cover + shrimp_long$size,family="poisson")
shrimpGLM5<-glm(shrimp_long$count ~ 1+ shrimp_long$Season + shrimp_long$seagrass_cover + shrimp_long$size + shrimp_long$towArea,family="poisson")
# interactions
shrimpGLM6<-glm(shrimp_long$count ~ 1+ shrimp_long$Season * shrimp_long$seagrass_cover + shrimp_long$size,family="poisson")
shrimpGLM7<-glm(shrimp_long$count ~ 1+ shrimp_long$Season * shrimp_long$seagrass_cover * shrimp_long$size + shrimp_long$towArea,family="poisson")
shrimpGLM8<-glm(shrimp_long$count ~ 1+ as.factor(shrimp_long$Season) * as.factor(shrimp_long$seagrass_cover) * shrimp_long$size * shrimp_long$towArea,family="poisson")

anova(shrimpGLM1,shrimpGLM2,shrimpGLM3,shrimpGLM4,shrimpGLM5,shrimpGLM6,shrimpGLM7,shrimpGLM8,test="Chisq")
```

```{r shrimpAICs}
shrimpAICs<-AIC(shrimpGLM1,shrimpGLM2,shrimpGLM3,shrimpGLM4,shrimpGLM5,shrimpGLM6,shrimpGLM7,shrimpGLM8)

shrimpAICs<-shrimpAICs[order(shrimpAICs$AIC),]
kable(shrimpAICs,"latex",booktab=TRUE,caption="Comparison of AICc values for model selection of Poisson GLMs describing shrimp abundances. The best-fitting model is the most complex one, with interactions between season, seagrass cover, shrimp size, and tow area.")
```

```{r}
shrimpGLM8<-glm(shrimp_long$count ~ 1+ as.factor(shrimp_long$Season) * as.factor(shrimp_long$seagrass_cover) * shrimp_long$size * shrimp_long$towArea,family="quasipoisson")

shrimpGLM8<-glm(shrimp_long$count ~ 1+ as.factor(shrimp_long$Season) * as.factor(shrimp_long$seagrass_cover) * shrimp_long$size * shrimp_long$towArea,family="quasipoisson")
```

log transform

```{r}
shrimpLM1<- lm(log(shrimp_long$density+1) ~ 1)
shrimpLM2<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season))
shrimpLM3<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$seagrass_cover))
shrimpLM4<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$size))
shrimpLM5<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) + as.factor(shrimp_long$seagrass_cover))
shrimpLM6<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) + shrimp_long$size)
shrimpLM7<-  lm(log(shrimp_long$density+1) ~ 1+  as.factor(shrimp_long$seagrass_cover) + shrimp_long$size)
shrimpLM8<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) + as.factor(shrimp_long$seagrass_cover) + shrimp_long$size)
shrimpLM9<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) * as.factor(shrimp_long$seagrass_cover) + shrimp_long$size)
shrimpLM10<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) + as.factor(shrimp_long$seagrass_cover) * shrimp_long$size)
shrimpLM11<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) * shrimp_long$size +as.factor(shrimp_long$seagrass_cover) )
shrimpLM12<-  lm(log(shrimp_long$density+1) ~ 1+ as.factor(shrimp_long$Season) * as.factor(shrimp_long$seagrass_cover) * shrimp_long$size)
anova(shrimpLM1,shrimpLM2,shrimpLM3,shrimpLM4,shrimpLM5,shrimpLM6,shrimpLM7,shrimpLM8,shrimpLM9,shrimpLM10,shrimpLM11,shrimpLM12)
```
```{r}
shrimpAIC<-AIC(shrimpLM1,shrimpLM2,shrimpLM3,shrimpLM4,shrimpLM5,shrimpLM6,shrimpLM7,shrimpLM8,shrimpLM9,shrimpLM10,shrimpLM11,shrimpLM12)
shrimpAIC<-shrimpAIC[order(shrimpAIC$AIC),]
kable(shrimpAIC,"latex",booktab=TRUE,caption="Comparison of AICc values for model selection of Poisson GLMs describing flounder abundances. The best-fitting model is the most complex one, with interactions between season, seagrass cover, flounder size, and tow area.")
```

```{r}
par(mfrow=c(2,2))
plot(shrimpLM12)
```
